export default {
  async fetch(request, env, ctx) {
    // 1. 定义 CORS 响应头
    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': '*',
    };

    // 2. 优先处理 OPTIONS 预检请求
    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    const url = new URL(request.url);
    const path = url.pathname;
    
    // --- 路由映射表配置 ---
    // /daily    -> 主端点 (Daily 环境)
    // /autopush -> 备用端点 (Autopush 环境)
    // /oauth2   -> 认证中心
    const routeMap = {
      '/daily': 'daily-cloudcode-pa.sandbox.googleapis.com',
      '/autopush': 'autopush-cloudcode-pa.sandbox.googleapis.com',
      '/oauth2': 'oauth2.googleapis.com'
    };
    // --------------------

    let targetHost = '';
    let matchedPrefix = '';

    // 遍历映射表寻找匹配的前缀
    for (const [prefix, host] of Object.entries(routeMap)) {
      if (path.startsWith(prefix)) {
        targetHost = host;
        matchedPrefix = prefix;
        break;
      }
    }

    // 如果没有匹配到任何路由，返回 404
    if (!targetHost) {
      return new Response(JSON.stringify({ 
        status: "Worker is active. Route not found.", 
        tips: "Please use /daily/..., /autopush/... or /oauth2/..." 
      }), {
        status: 404,
        headers: { ...corsHeaders, 'content-type': 'application/json' }
      });
    }

    // 3. 重写 URL
    url.hostname = targetHost;
    // 去掉前缀，保留剩余路径。例如 /daily/v1internal... 变成 /v1internal...
    url.pathname = path.replace(matchedPrefix, ''); 

    // 4. 清洗请求头 (防止谷歌识别出代理或因为 Host 不匹配拒绝)
    const newHeaders = new Headers(request.headers);

    // ✅ 修复1：设置正确的 Host 头（之前删除了可能导致问题）
    newHeaders.set('Host', targetHost);

    // 只删除 Cloudflare 特有的头
    newHeaders.delete('cf-connecting-ip');
    newHeaders.delete('cf-ipcountry');
    newHeaders.delete('cf-ray');
    newHeaders.delete('cf-visitor');
    newHeaders.delete('x-forwarded-proto');
    newHeaders.delete('x-real-ip');
    newHeaders.delete('Origin');
    newHeaders.delete('Referer');

    // 5. 构造新请求
    const newRequest = new Request(url.toString(), {
      method: request.method,
      headers: newHeaders,
      // ✅ 修复2：GET 和 HEAD 请求不应该带 body
      body: request.method !== 'GET' && request.method !== 'HEAD'
        ? request.body
        : undefined,
      redirect: 'follow'
    });

    try {
      const response = await fetch(newRequest);
      
      // 6. 重新包装响应，确保 CORS 头存在
      const newResponse = new Response(response.body, response);
      newResponse.headers.set('Access-Control-Allow-Origin', '*');
      
      return newResponse;
    } catch (e) {
      return new Response(JSON.stringify({ error: e.message }), { 
        status: 500,
        headers: corsHeaders
      });
    }
  }
};